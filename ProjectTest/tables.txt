/*THESE TABLES ARE ALMOST COMPLETE THEY STILL NEEED.
- Cascade deletion as specified in our docs
- the functions that we also specified*/ 

CREATE TABLE app_hotel_chain(
    chain_ID int NOT NULL,
    address VARCHAR(150),
    name VARCHAR(150),
    nTelephones VARCHAR(30),
    email VARCHAR(150),
    rating int NOT NULL,
    image_url VARCHAR(500),
    numberOfHotels int NOT NULL,
    PRIMARY KEY(chain_ID)
);

CREATE TABLE app_hotel(
    hotel_ID int NOT NULL,
    address VARCHAR(150),
    zone VARCHAR(150),
	name VARCHAR(50),
    nTelephones VARCHAR(30),
    email VARCHAR(150),
    rating int NOT NULL,
    image_url VARCHAR(500),
    numberOfRooms int NOT NULL,
    chain_ID int NOT NULL,
    PRIMARY KEY(hotel_ID),
	FOREIGN KEY (chain_ID) REFERENCES app_hotel_chain
);

CREATE TABLE app_capacity(
    capacity VARCHAR(20),
	ID int NOT NULL,
    PRIMARY KEY(ID)
);

CREATE TABLE app_room(
    ID BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    room_number INT NOT NULL,
    price numeric(20,2) NOT NULL,
    view VARCHAR(50),
    capaCity_ID int NOT NULL,
	FOREIGN KEY (capacity_ID) REFERENCES app_capacity,
    extra_bed BOOLEAN,
	hotel_ID int NOT NULL ,
	FOREIGN KEY(hotel_ID) REFERENCES app_hotel,
    UNIQUE(room_number,hotel_ID),
    PRIMARY KEY (ID)
);

CREATE TABLE app_client(
    first_name   VARCHAR(20) NOT NULL,
    middle_name  VARCHAR(20),
    last_name   VARCHAR(20) NOT NULL,
    address VARCHAR(150) NOT NULL,
    ssa VARCHAR(100) NOT NULL,
    PRIMARY KEY (ssa)
);

CREATE TABLE app_card(
    card_number VARCHAR(25) NOT NULL,
    expiry_date VARCHAR(8) NOT NULL,
    cvv VARCHAR(4) NOT NULL,
    name_on_the_card VARCHAR(50) NOT NULL,
    PRIMARY KEY(card_number)
);

CREATE TABLE app_payment(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    card_info_id VARCHAR(25) NOT NULL,
    FOREIGN KEY(card_info_id) REFERENCES app_card(card_number),
    amount NUMERIC(20,2) NOT NULL,
    client_id VARCHAR(100) NOT NULL,
    FOREIGN KEY (client_id) REFERENCES app_client(ssa)
);

CREATE TABLE app_reservation(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    date_of_reservation DATE NOT NULL
    start_time DATE NOT NULL,
    end_time DATE NOT NULL,
    client_id VARCHAR(100) NOT NULL,
	FOREIGN KEY (client_id) REFERENCES app_client(ssa),
    hotel_id int NOT NULL,
	FOREIGN KEY (hotel_id) REFERENCES app_hotel(hotel_id),
    view VARCHAR(50),
    capacity_id int NOT NULL,
    extraBed BOOLEAN NOT NULL,
    price FLOAT(20) NOT NULL,
    PRIMARY KEY (id)
);



CREATE TABLE app_payment_for(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    payment_id bigint NOT NULL,
    reservation_id INT NOT NULL,
    FOREIGN KEY (reservation_id) REFERENCES app_reservation(id),
    payment INT NOT NULL,
    FOREIGN KEY (payment) REFERENCES app_payment(id),
    PRIMARY KEY (id)
);

CREATE TABLE app_damage(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    description VARCHAR(250) NOT NULL,
    room_id bigint NOT NULL,
    FOREIGN KEY (room_id) REFERENCES app_room(id),
    PRIMARY KEY (id)
);

CREATE TABLE app_commodity(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    type VARCHAR(100) NOT NULL,
    description VARCHAR(250) NOT NULL,
    room_id bigint NOT NULL,
    FOREIGN KEY (room_id) REFERENCES app_room(id),
    PRIMARY KEY(id)
);

CREATE TABLE app_employee(
    ssa VARCHAR(100) NOT NULL,
    first_name VARCHAR(20) NOT NULL,
    middle_name VARCHAR(20),
    last_name VARCHAR(20) NOT NULL,
    post VARCHAR(150) NOT NULL,
    password VARCHAR(128) NOT NULL,
    PRIMARY KEY(ssa)
);

CREATE TABLE app_works_for(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    employee_id VARCHAR(100) NOT NULL,
    hotel_id int NOT NULL,
    FOREIGN KEY (employee_id) REFERENCES app_employee(ssa),
    FOREIGN KEY (hotel_id) REFERENCES app_hotel(hotel_id),
    PRIMARY KEY (id)
);

CREATE INDEX indexByRoomNumber
ON app_room(room_number);

CREATE INDEX indexByNameHotel
ON app_hotel(name);

CREATE INDEX indexByNameChain
ON app_hotel_chain(name);

CREATE INDEX indexByZone
ON app_hotel(zone);



/*NOTICE THAT IN LOCATION
 S time needs to be the same
 as in reservation (But the ennd time might change so we need to fix that) 
 I also added hotel id here to not lose track of which specific room we are talking about*/
SET search_path = 'SAILORS';
CREATE TABLE location(
    location_ID int NOT NULL,
    sTime TIMESTAMP DEFAULT NULL,
    eTime TIMESTAMP DEFAULT NULL,
    in_person BOOLEAN,
    client_ID int NOT NULL,
    hotel_ID int NOT NULL,
    SSN_employee int NOT NULL,
    rNumber int NOT NULL,
    FOREIGN KEY (SSN_employee) REFERENCES employee,
    FOREIGN KEY (client_ID,hotel_ID,sTime) REFERENCES reservation,
    PRIMARY KEY(location_ID)
);

/*(10%) L’utilisateur doit pouvoir également voir deux vues spécifiques. Vous devez
implémenter les vues en tant que vues SQL. Vue 1: la première vue est le nombre de chambres
disponibles par zone. Vue 2: la deuxième vue est la capacité de toutes les chambres d’un hôtel
spécifique. 




CREATE VIEW CAPACITY AS
SELECT C.capacity,R.room_number,H.name
FROM app_hotel H 
NATURAL JOIN app_room R NATURAL JOIN app_capacity C
GROUP BY (H.name,C.capacity,R.room_number);


/*This second view where available
measn that the room has no damage */
CREATE VIEW AVAILABILITY AS
SELECT H.zone, Count(distinct R.id)
FROM app_Hotel H NATURAL JOIN app_room R
where R.id not in(SELECT room_id from app_damage) and R.hotel_id_id=H.hotel_id
GROUP BY H.zone;







/*These two functions create the
archive table and insert every information into them*/



CREATE TABLE reservation_archive AS 
TABLE app_reservation;

CREATE TABLE location_archive AS 
TABLE app_location;




/*These two triggers
insert information into the archive tables
every time it is inserted on the original tables */

CREATE FUNCTION insert_New_location() RETURNS trigger AS $$
    BEGIN
       INSERT INTO location_archive VALUES((NEW).*);
       RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_New_location
BEFORE INSERT ON app_location 
FOR EACH ROW
EXECUTE PROCEDURE insert_New_location();

CREATE FUNCTION insert_New_reservation() RETURNS trigger AS $$
    BEGIN
       INSERT INTO reservation_archive VALUES((NEW).*);
       RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_New_reservation
BEFORE INSERT ON app_reservation 
FOR EACH ROW
EXECUTE PROCEDURE insert_New_reservation();


/*These two finctions insert 
information into the archive everytime there is an update
so that we have in the archive the information available
for the things before and after the update */

CREATE FUNCTION update_location() RETURNS trigger AS $$
    BEGIN
       INSERT INTO location_archive VALUES((NEW).*);
       RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_location
BEFORE UPDATE ON app_location 
FOR EACH ROW
EXECUTE PROCEDURE update_location();


CREATE FUNCTION update_reservation() RETURNS trigger AS $$
    BEGIN
       INSERT INTO reservation_archive VALUES((NEW).*);
       RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_reservation
BEFORE UPDATE ON app_reservation
FOR EACH ROW
EXECUTE PROCEDURE update_reservation();