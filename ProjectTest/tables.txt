/*THESE TABLES ARE ALMOST COMPLETE THEY STILL NEEED.
- Cascade deletion as specified in our docs
- the functions that we also specified*/ 

CREATE TABLE app_hotel_chain(
    chain_ID int NOT NULL,
    address VARCHAR(150),
    name VARCHAR(150),
    nTelephones VARCHAR(30),
    email VARCHAR(150),
    rating int NOT NULL,
    image_url VARCHAR(500),
    numberOfHotels int NOT NULL,
    PRIMARY KEY(chain_ID)
);

CREATE TABLE app_hotel(
    hotel_ID int NOT NULL,
    address VARCHAR(150),
    zone VARCHAR(150),
	name VARCHAR(50),
    nTelephones VARCHAR(30),
    email VARCHAR(150),
    rating int NOT NULL,
    image_url VARCHAR(500),
    numberOfRooms int NOT NULL,
    chain_ID int NOT NULL,
    PRIMARY KEY(hotel_ID),
	FOREIGN KEY (chain_ID) REFERENCES app_hotel_chain
);

CREATE TABLE app_capacity(
    capacity VARCHAR(20),
	ID int NOT NULL,
    PRIMARY KEY(ID)
);

CREATE TABLE app_room(
    ID BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    room_number INT NOT NULL,
    price numeric(20,2) NOT NULL,
    view VARCHAR(50),
    capaCity_ID int NOT NULL,
	FOREIGN KEY (capacity_ID) REFERENCES app_capacity,
    extra_bed BOOLEAN,
	hotel_ID int NOT NULL ,
	FOREIGN KEY(hotel_ID) REFERENCES app_hotel,
    UNIQUE(room_number,hotel_ID),
    PRIMARY KEY (ID)
);

CREATE TABLE app_client(
    first_name   VARCHAR(20) NOT NULL,
    middle_name  VARCHAR(20),
    last_name   VARCHAR(20) NOT NULL,
    address VARCHAR(150) NOT NULL,
    ssa VARCHAR(100) NOT NULL,
    PRIMARY KEY (ssa)
);

CREATE TABLE app_card(
    card_number VARCHAR(25) NOT NULL,
    expiry_date VARCHAR(8) NOT NULL,
    cvv VARCHAR(4) NOT NULL,
    name_on_the_card VARCHAR(50) NOT NULL,
    PRIMARY KEY(card_number)
);

CREATE TABLE app_payment(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    card_info_id VARCHAR(25) NOT NULL,
    FOREIGN KEY(card_info_id) REFERENCES app_card(card_number),
    amount NUMERIC(20,2) NOT NULL,
    client_id VARCHAR(100) NOT NULL,
    FOREIGN KEY (client_id) REFERENCES app_client(ssa)
);

CREATE TABLE app_reservation(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    date_of_reservation DATE NOT NULL
    start_time DATE NOT NULL,
    end_time DATE NOT NULL,
    client_id VARCHAR(100) NOT NULL,
	FOREIGN KEY (client_id) REFERENCES app_client(ssa),
    hotel_id int NOT NULL,
	FOREIGN KEY (hotel_id) REFERENCES app_hotel(hotel_id),
    view VARCHAR(50),
    capacity_id int NOT NULL,
    extraBed BOOLEAN NOT NULL,
    price FLOAT(20) NOT NULL,
    PRIMARY KEY (id)
);



CREATE TABLE app_payment_for(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    payment_id bigint NOT NULL,
    reservation_id INT NOT NULL,
    FOREIGN KEY (reservation_id) REFERENCES app_reservation(id),
    payment INT NOT NULL,
    FOREIGN KEY (payment) REFERENCES app_payment(id),
    PRIMARY KEY (id)
);

CREATE TABLE app_damage(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    description VARCHAR(250) NOT NULL,
    room_id bigint NOT NULL,
    FOREIGN KEY (room_id) REFERENCES app_room(id),
    PRIMARY KEY (id)
);

CREATE TABLE app_commodity(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    type VARCHAR(100) NOT NULL,
    description VARCHAR(250) NOT NULL,
    room_id bigint NOT NULL,
    FOREIGN KEY (room_id) REFERENCES app_room(id),
    PRIMARY KEY(id)
);

CREATE INDEX indexByRoomNumber
ON app_room(room_number);

CREATE INDEX indexByNameHotel
ON app_hotel(name);

CREATE INDEX indexByNameChain
ON app_hotel_chain(name);

CREATE INDEX indexByZone
ON app_hotel(zone);




CREATE TABLE views(
    description VARCHAR(20),
	views_ID int NOT NULL,
    PRIMARY KEY(views_ID)
);





CREATE TABLE employee(
    FirstName         VARCHAR(50) NOT NULL,
    MiddleName    VARCHAR(50),
    LastName          VARCHAR(50)NOT NULL,
    eAddress VARCHAR(254),
    role VARCHAR(15),
    SSN_employee int NOT NULL,
    PRIMARY KEY(SSN_employee)
);



CREATE TABLE damage(
    damage_ID int NOT NULL,
    rNumber int,
	hotel_ID int,
	FOREIGN KEY (rNumber,hotel_ID) REFERENCES room,
	/* In the lack of a better way to connect each damage
	to its room id which is composite I used both of the elements of
	the composite primary key in room */
    description VARCHAR(200),
    PRIMARY KEY (damage_ID)
);

CREATE TABLE commodity(
    commodity_ID int NOT NULL AUTO_INCREMENT,
    type VARCHAR(10),
    description CHAR(25),
    PRIMARY KEY(commodity_ID)
);

CREATE TABLE commodity(
    commodity_ID int NOT NULL,
    type VARCHAR(10),
    description CHAR(25),
    PRIMARY KEY(commodity_ID)
);

/*NOTICE THAT IN LOCATION
 S time needs to be the same
 as in reservation (But the ennd time might change so we need to fix that) 
 I also added hotel id here to not lose track of which specific room we are talking about*/
SET search_path = 'SAILORS';
CREATE TABLE location(
    location_ID int NOT NULL,
    sTime TIMESTAMP DEFAULT NULL,
    eTime TIMESTAMP DEFAULT NULL,
    in_person BOOLEAN,
    client_ID int NOT NULL,
    hotel_ID int NOT NULL,
    SSN_employee int NOT NULL,
    rNumber int NOT NULL,
    FOREIGN KEY (SSN_employee) REFERENCES employee,
    FOREIGN KEY (client_ID,hotel_ID,sTime) REFERENCES reservation,
    PRIMARY KEY(location_ID)
);

CREATE TABLE payment(
    payment_ID int NOT NULL,
    amount FLOAT,
    method VARCHAR(25),
    client_ID int NOT NULL,
    FOREIGN KEY (client_ID) REFERENCES client,
    location_ID int NOT NULL,
    FOREIGN KEY (location_ID) REFERENCES location,
    PRIMARY KEY(payment_ID)
);

/*(10%) L’utilisateur doit pouvoir également voir deux vues spécifiques. Vous devez
implémenter les vues en tant que vues SQL. Vue 1: la première vue est le nombre de chambres
disponibles par zone. Vue 2: la deuxième vue est la capacité de toutes les chambres d’un hôtel
spécifique. 


/*
It includes the information a client would probably
want to see when booking a hotel,
so it doesnt include damages or
 any of the ids just rNumber
 This would probably need a where class 
 to check if the room is available
 */

CREATE VIEW Room_Info_with_Capacity AS
SELECT H.name,H.address,
H.ntelephones,H.rating,R.room_number,
C.capacity, R.price, R.view
FROM app_hotel H 
NATURAL JOIN app_room R NATURAL JOIN app_capacity C
GROUP BY C.capacity;



/*This second view where available
measn that the room has no damage */
CREATE VIEW Room_Available AS
SELECT Count(R.room_number), H.zone
FROM app_Room R, app_Hotel H, app_damage D
WHERE H.ID=R.hotel_id, D.room_number !=R.room_number, D.hotel_id!=R.hotel_id,
H.ID!= D.hotel_id
GROUP BY H.zone;






/*These two functions create the
archive table and insert every information into them*/



CREATE TABLE reservation_archive AS 
TABLE reservation;

CREATE TABLE location_archive AS 
TABLE location;




/*These two triggers
insert information into the archive tables
every time it is inserted on the original tables */

CREATE FUNCTION insert_New_location() RETURNS trigger AS $$
    BEGIN
       INSERT INTO location_archive VALUES((NEW).*);
       RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_New_location
BEFORE INSERT ON location 
FOR EACH ROW
EXECUTE PROCEDURE insert_New_location();

CREATE FUNCTION insert_New_reservation() RETURNS trigger AS $$
    BEGIN
       INSERT INTO reservation_archive VALUES((NEW).*);
       RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_New_reservation
BEFORE INSERT ON reservation 
FOR EACH ROW
EXECUTE PROCEDURE insert_New_reservation();


/*These two finctions insert 
information into the archive everytime there is an update
so that we have in the archive the information available
for the things before and after the update */

CREATE FUNCTION update_location() RETURNS trigger AS $$
    BEGIN
       INSERT INTO location_archive VALUES((NEW).*);
       RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_location
BEFORE UPDATE ON location 
FOR EACH ROW
EXECUTE PROCEDURE update_location();


CREATE FUNCTION update_reservation() RETURNS trigger AS $$
    BEGIN
       INSERT INTO reservation_archive VALUES((NEW).*);
       RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_reservation
BEFORE UPDATE ON reservation
FOR EACH ROW
EXECUTE PROCEDURE update_reservation();